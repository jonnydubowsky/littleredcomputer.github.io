{"version":3,"names":[],"mappings":"","sources":["js/standard-map.bundle.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.standardmap = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n(function (Outcome) {\n    Outcome[Outcome[\"Converged\"] = 0] = \"Converged\";\n    Outcome[Outcome[\"MaxStepsExceeded\"] = 1] = \"MaxStepsExceeded\";\n    Outcome[Outcome[\"EarlyReturn\"] = 2] = \"EarlyReturn\";\n})(exports.Outcome || (exports.Outcome = {}));\nvar Outcome = exports.Outcome;\nvar Solver = (function () {\n    function Solver(n) {\n        this.n = n;\n        this.uRound = 2.3e-16;\n        this.maxSteps = 10000;\n        this.initialStepSize = 1e-4;\n        this.maxStepSize = 0;\n        this.maxExtrapolationColumns = 9;\n        this.stepSizeSequence = 0;\n        this.stabilityCheckCount = 1;\n        this.stabilityCheckTableLines = 2;\n        this.denseOutput = false;\n        this.denseOutputErrorEstimator = true;\n        this.denseComponents = undefined;\n        this.interpolationFormulaDegree = 4;\n        this.stepSizeReductionFactor = 0.5;\n        this.stepSizeFac1 = 0.02;\n        this.stepSizeFac2 = 4.0;\n        this.stepSizeFac3 = 0.8;\n        this.stepSizeFac4 = 0.9;\n        this.stepSafetyFactor1 = 0.65;\n        this.stepSafetyFactor2 = 0.94;\n        this.relativeTolerance = 1e-5;\n        this.absoluteTolerance = 1e-5;\n        this.debug = false;\n    }\n    Solver.prototype.grid = function (dt, out) {\n        var components = this.denseComponents;\n        if (!components) {\n            components = [];\n            for (var i = 0; i < this.n; ++i)\n                components.push(i);\n        }\n        var t;\n        return function (n, xOld, x, y, interpolate) {\n            if (n === 1) {\n                out(x, y);\n                t = x + dt;\n                return;\n            }\n            while (t <= x) {\n                var yf = [];\n                for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {\n                    var i = components_1[_i];\n                    yf.push(interpolate(i, t));\n                }\n                out(t, yf);\n                t += dt;\n            }\n        };\n    };\n    Solver.dim2 = function (r, c) {\n        var a = new Array(r + 1);\n        for (var i = 1; i <= r; ++i)\n            a[i] = Solver.dim(c);\n        return a;\n    };\n    Solver.stepSizeSequence = function (nSeq, n) {\n        var a = new Array(n + 1);\n        a[0] = 0;\n        switch (nSeq) {\n            case 1:\n                for (var i = 1; i <= n; ++i)\n                    a[i] = 2 * i;\n                break;\n            case 2:\n                a[1] = 2;\n                for (var i = 2; i <= n; ++i)\n                    a[i] = 4 * i - 4;\n                break;\n            case 3:\n                a[1] = 2;\n                a[2] = 4;\n                a[3] = 6;\n                for (var i = 4; i <= n; ++i)\n                    a[i] = 2 * a[i - 2];\n                break;\n            case 4:\n                for (var i = 1; i <= n; ++i)\n                    a[i] = 4 * i - 2;\n                break;\n            case 5:\n                for (var i = 1; i <= n; ++i)\n                    a[i] = 4 * i;\n                break;\n            default:\n                throw new Error('invalid stepSizeSequence selected');\n        }\n        return a;\n    };\n    Solver.prototype.solve = function (f, x, y0, xEnd, solOut) {\n        var _this = this;\n        var y = [0].concat(y0);\n        var dz = Solver.dim(this.n);\n        var yh1 = Solver.dim(this.n);\n        var yh2 = Solver.dim(this.n);\n        if (this.maxSteps <= 0)\n            throw new Error('maxSteps must be positive');\n        var km = this.maxExtrapolationColumns;\n        if (km <= 2)\n            throw new Error('maxExtrapolationColumns must be > 2');\n        var nSeq = this.stepSizeSequence || (this.denseOutput ? 4 : 1);\n        if (nSeq <= 3 && this.denseOutput)\n            throw new Error('stepSizeSequence incompatible with denseOutput');\n        if (this.denseOutput && !solOut)\n            throw new Error('denseOutput requires a solution observer function');\n        if (this.interpolationFormulaDegree <= 0 || this.interpolationFormulaDegree >= 7)\n            throw new Error('bad interpolationFormulaDegree');\n        var icom = [0];\n        var nrdens = 0;\n        if (this.denseOutput) {\n            if (this.denseComponents) {\n                for (var _i = 0, _a = this.denseComponents; _i < _a.length; _i++) {\n                    var c = _a[_i];\n                    if (c < 0 || c > this.n)\n                        throw new Error('bad dense component: ' + c);\n                    icom.push(c + 1);\n                    ++nrdens;\n                }\n            }\n            else {\n                for (var i = 1; i <= this.n; ++i) {\n                    icom.push(i);\n                }\n                nrdens = this.n;\n            }\n        }\n        if (this.uRound <= 1e-35 || this.uRound > 1)\n            throw new Error('suspicious value of uRound');\n        var hMax = Math.abs(this.maxStepSize || xEnd - x);\n        var lfSafe = 2 * km * km + km;\n        function expandToArray(x, n) {\n            var tolArray = [0];\n            if (Array.isArray(x)) {\n                return tolArray.concat(x);\n            }\n            else {\n                for (var i = 0; i < n; ++i)\n                    tolArray.push(x);\n                return tolArray;\n            }\n        }\n        var aTol = expandToArray(this.absoluteTolerance, this.n);\n        var rTol = expandToArray(this.relativeTolerance, this.n);\n        var nEval = 0;\n        var nStep = 0;\n        var nAccept = 0;\n        var nReject = 0;\n        var nrd = Math.max(1, nrdens);\n        var ncom = Math.max(1, (2 * km + 5) * nrdens);\n        var dens = Solver.dim(ncom);\n        var fSafe = Solver.dim2(lfSafe, nrd);\n        var F = function (x, y, yp) {\n            var yp1 = yp.slice(1);\n            var ret = f(x, y.slice(1), yp1);\n            if (Array.isArray(ret))\n                yp.splice.apply(yp, [1, _this.n].concat(ret));\n            else\n                yp.splice.apply(yp, [1, _this.n].concat(yp1));\n        };\n        var odxcor = function () {\n            var xOldd;\n            var hhh;\n            var kmit;\n            var acceptStep = function (n) {\n                xOld = x;\n                x += h;\n                if (_this.denseOutput) {\n                    kmit = 2 * kc - _this.interpolationFormulaDegree + 1;\n                    for (var i = 1; i <= nrd; ++i)\n                        dens[i] = y[icom[i]];\n                    xOldd = xOld;\n                    hhh = h;\n                    for (var i = 1; i <= nrd; ++i)\n                        dens[nrd + i] = h * dz[icom[i]];\n                    var kln = 2 * nrd;\n                    for (var i = 1; i <= nrd; ++i)\n                        dens[kln + i] = t[1][icom[i]];\n                    for (var j = 2; j <= kc; ++j) {\n                        var dblenj = nj[j];\n                        for (var l = j; l >= 2; --l) {\n                            var factor = Math.pow(dblenj / nj[l - 1], 2) - 1;\n                            for (var i = 1; i <= nrd; ++i) {\n                                ySafe[l - 1][i] = ySafe[l][i] + (ySafe[l][i] - ySafe[l - 1][i]) / factor;\n                            }\n                        }\n                    }\n                    var krn = 4 * nrd;\n                    for (var i = 1; i <= nrd; ++i)\n                        dens[krn + i] = ySafe[1][i];\n                    for (var i = 1; i <= n; ++i)\n                        yh1[i] = t[1][i];\n                    F(x, yh1, yh2);\n                    krn = 3 * nrd;\n                    for (var i = 1; i <= nrd; ++i)\n                        dens[krn + i] = yh2[icom[i]] * h;\n                    for (var kmi = 1; kmi <= kmit; ++kmi) {\n                        var kbeg = (kmi + 1) / 2 | 0;\n                        for (var kk = kbeg; kk <= kc; ++kk) {\n                            var facnj = Math.pow(nj[kk] / 2, kmi - 1);\n                            iPt = iPoint[kk + 1] - 2 * kk + kmi;\n                            for (var i = 1; i <= nrd; ++i) {\n                                ySafe[kk][i] = fSafe[iPt][i] * facnj;\n                            }\n                        }\n                        for (var j = kbeg + 1; j <= kc; ++j) {\n                            var dblenj = nj[j];\n                            for (var l = j; l >= kbeg + 1; --l) {\n                                var factor = Math.pow(dblenj / nj[l - 1], 2) - 1;\n                                for (var i = 1; i <= nrd; ++i) {\n                                    ySafe[l - 1][i] = ySafe[l][i] + (ySafe[l][i] - ySafe[l - 1][i]) / factor;\n                                }\n                            }\n                        }\n                        krn = (kmi + 4) * nrd;\n                        for (var i = 1; i <= nrd; ++i)\n                            dens[krn + i] = ySafe[kbeg][i] * h;\n                        if (kmi === kmit)\n                            continue;\n                        for (var kk = (kmi + 2) / 2 | 0; kk <= kc; ++kk) {\n                            var lbeg = iPoint[kk + 1];\n                            var lend = iPoint[kk] + kmi + 1;\n                            if (kmi === 1 && nSeq === 4)\n                                lend += 2;\n                            var l = void 0;\n                            for (l = lbeg; l >= lend; l -= 2) {\n                                for (var i = 1; i <= nrd; ++i) {\n                                    fSafe[l][i] -= fSafe[l - 2][i];\n                                }\n                            }\n                            if (kmi === 1 && nSeq === 4) {\n                                l = lend - 2;\n                                for (var i = 1; i <= nrd; ++i)\n                                    fSafe[l][i] -= dz[icom[i]];\n                            }\n                        }\n                        for (var kk = (kmi + 2) / 2 | 0; kk <= kc; ++kk) {\n                            var lbeg = iPoint[kk + 1] - 1;\n                            var lend = iPoint[kk] + kmi + 2;\n                            for (var l = lbeg; l >= lend; l -= 2) {\n                                for (var i = 1; i <= nrd; ++i) {\n                                    fSafe[l][i] -= fSafe[l - 2][i];\n                                }\n                            }\n                        }\n                    }\n                    interp(nrd, dens, kmit);\n                    if (_this.denseOutputErrorEstimator && kmit >= 1) {\n                        var errint = 0;\n                        for (var i = 1; i <= nrd; ++i)\n                            errint += Math.pow(dens[(kmit + 4) * nrd + i] / scal[icom[i]], 2);\n                        errint = Math.sqrt(errint / nrd) * errfac[kmit];\n                        hoptde = h / Math.max(Math.pow(errint, 1 / (kmit + 4)), 0.01);\n                        if (errint > 10) {\n                            h = hoptde;\n                            x = xOld;\n                            ++nReject;\n                            reject = true;\n                            return true;\n                        }\n                    }\n                    for (var i = 1; i <= n; ++i)\n                        dz[i] = yh2[i];\n                }\n                for (var i = 1; i <= n; ++i)\n                    y[i] = t[1][i];\n                ++nAccept;\n                if (solOut) {\n                    if (solOut(nAccept + 1, xOld, x, y.slice(1), _this.denseOutput && contex(xOldd, hhh, kmit, dens, icom)) === false)\n                        return false;\n                }\n                var kopt;\n                if (kc === 2) {\n                    kopt = Math.min(3, km - 1);\n                    if (reject)\n                        kopt = 2;\n                }\n                else {\n                    if (kc <= k) {\n                        kopt = kc;\n                        if (w[kc - 1] < w[kc] * _this.stepSizeFac3)\n                            kopt = kc - 1;\n                        if (w[kc] < w[kc - 1] * _this.stepSizeFac4)\n                            kopt = Math.min(kc + 1, km - 1);\n                    }\n                    else {\n                        kopt = kc - 1;\n                        if (kc > 3 && w[kc - 2] < w[kc - 1] * _this.stepSizeFac3)\n                            kopt = kc - 2;\n                        if (w[kc] < w[kopt] * _this.stepSizeFac4)\n                            kopt = Math.min(kc, km - 1);\n                    }\n                }\n                if (reject) {\n                    k = Math.min(kopt, kc);\n                    h = posneg * Math.min(Math.abs(h), Math.abs(hh[k]));\n                    reject = false;\n                    return true;\n                }\n                if (kopt <= kc) {\n                    h = hh[kopt];\n                }\n                else {\n                    if (kc < k && w[kc] < w[kc - 1] * _this.stepSizeFac4) {\n                        h = hh[kc] * a[kopt + 1] / a[kc];\n                    }\n                    else {\n                        h = hh[kc] * a[kopt] / a[kc];\n                    }\n                }\n                k = kopt;\n                h = posneg * Math.abs(h);\n                return true;\n            };\n            var midex = function (j) {\n                var dy = Solver.dim(_this.n);\n                var hj = h / nj[j];\n                for (var i = 1; i <= _this.n; ++i) {\n                    yh1[i] = y[i];\n                    yh2[i] = y[i] + hj * dz[i];\n                }\n                var m = nj[j] - 1;\n                var njMid = (nj[j] / 2) | 0;\n                for (var mm = 1; mm <= m; ++mm) {\n                    if (_this.denseOutput && mm === njMid) {\n                        for (var i = 1; i <= nrd; ++i) {\n                            ySafe[j][i] = yh2[icom[i]];\n                        }\n                    }\n                    F(x + hj * mm, yh2, dy);\n                    if (_this.denseOutput && Math.abs(mm - njMid) <= 2 * j - 1) {\n                        ++iPt;\n                        for (var i = 1; i <= nrd; ++i) {\n                            fSafe[iPt][i] = dy[icom[i]];\n                        }\n                    }\n                    for (var i = 1; i <= _this.n; ++i) {\n                        var ys = yh1[i];\n                        yh1[i] = yh2[i];\n                        yh2[i] = ys + 2 * hj * dy[i];\n                    }\n                    if (mm <= _this.stabilityCheckCount && j <= _this.stabilityCheckTableLines) {\n                        var del1 = 0;\n                        for (var i = 1; i <= _this.n; ++i) {\n                            del1 += Math.pow(dz[i] / scal[i], 2);\n                        }\n                        var del2 = 0;\n                        for (var i = 1; i <= _this.n; ++i) {\n                            del2 += Math.pow((dy[i] - dz[i]) / scal[i], 2);\n                        }\n                        var quot = del2 / Math.max(_this.uRound, del1);\n                        if (quot > 4) {\n                            ++nEval;\n                            atov = true;\n                            h *= _this.stepSizeReductionFactor;\n                            reject = true;\n                            return;\n                        }\n                    }\n                }\n                F(x + h, yh2, dy);\n                if (_this.denseOutput && njMid <= 2 * j - 1) {\n                    ++iPt;\n                    for (var i = 1; i <= nrd; ++i) {\n                        fSafe[iPt][i] = dy[icom[i]];\n                    }\n                }\n                for (var i = 1; i <= _this.n; ++i) {\n                    t[j][i] = (yh1[i] + yh2[i] + hj * dy[i]) / 2;\n                }\n                nEval += nj[j];\n                if (j === 1)\n                    return;\n                var dblenj = nj[j];\n                var fac;\n                for (var l = j; l > 1; --l) {\n                    fac = Math.pow(dblenj / nj[l - 1], 2) - 1;\n                    for (var i = 1; i <= _this.n; ++i) {\n                        t[l - 1][i] = t[l][i] + (t[l][i] - t[l - 1][i]) / fac;\n                    }\n                }\n                err = 0;\n                for (var i = 1; i <= _this.n; ++i) {\n                    var t1i = Math.max(Math.abs(y[i]), Math.abs(t[1][i]));\n                    scal[i] = aTol[i] + rTol[i] * t1i;\n                    err += Math.pow((t[1][i] - t[2][i]) / scal[i], 2);\n                }\n                err = Math.sqrt(err / _this.n);\n                if (err * _this.uRound >= 1 || (j > 2 && err >= errOld)) {\n                    atov = true;\n                    h *= _this.stepSizeReductionFactor;\n                    reject = true;\n                    return;\n                }\n                errOld = Math.max(4 * err, 1);\n                var exp0 = 1 / (2 * j - 1);\n                var facMin = Math.pow(_this.stepSizeFac1, exp0);\n                fac = Math.min(_this.stepSizeFac2 / facMin, Math.max(facMin, Math.pow(err / _this.stepSafetyFactor1, exp0) / _this.stepSafetyFactor2));\n                fac = 1 / fac;\n                hh[j] = Math.min(Math.abs(h) * fac, hMax);\n                w[j] = a[j] / hh[j];\n            };\n            var interp = function (n, y, imit) {\n                var a = new Array(31);\n                for (var i = 1; i <= n; ++i) {\n                    var y0_1 = y[i];\n                    var y1 = y[2 * n + i];\n                    var yp0 = y[n + i];\n                    var yp1 = y[3 * n + i];\n                    var yDiff = y1 - y0_1;\n                    var aspl = -yp1 + yDiff;\n                    var bspl = yp0 - yDiff;\n                    y[n + i] = yDiff;\n                    y[2 * n + i] = aspl;\n                    y[3 * n + i] = bspl;\n                    if (imit < 0)\n                        continue;\n                    var ph0 = (y0_1 + y1) * 0.5 + 0.125 * (aspl + bspl);\n                    var ph1 = yDiff + (aspl - bspl) * 0.25;\n                    var ph2 = -(yp0 - yp1);\n                    var ph3 = 6 * (bspl - aspl);\n                    if (imit >= 1) {\n                        a[1] = 16 * (y[5 * n + i] - ph1);\n                        if (imit >= 3) {\n                            a[3] = 16 * (y[7 * n + i] - ph3 + 3 * a[1]);\n                            if (imit >= 5) {\n                                for (var im = 5; im <= imit; im += 2) {\n                                    var fac1 = im * (im - 1) / 2;\n                                    var fac2 = fac1 * (im - 2) * (im - 3) * 2;\n                                    a[im] = 16 * (y[(im + 4) * n + i] + fac1 * a[im - 2] - fac2 * a[im - 4]);\n                                }\n                            }\n                        }\n                    }\n                    a[0] = (y[4 * n + i] - ph0) * 16;\n                    if (imit >= 2) {\n                        a[2] = (y[n * 6 + i] - ph2 + a[0]) * 16;\n                        if (imit >= 4) {\n                            for (var im = 4; im <= imit; im += 2) {\n                                var fac1 = im * (im - 1) / 2;\n                                var fac2 = im * (im - 1) * (im - 2) * (im - 3);\n                                a[im] = (y[n * (im + 4) + i] + a[im - 2] * fac1 - a[im - 4] * fac2) * 16;\n                            }\n                        }\n                    }\n                    for (var im = 0; im <= imit; ++im)\n                        y[n * (im + 4) + i] = a[im];\n                }\n            };\n            var contex = function (xOld, h, imit, y, icom) {\n                return function (c, x) {\n                    var i = 0;\n                    for (var j = 1; j <= nrd; ++j) {\n                        if (icom[j] === c + 1)\n                            i = j;\n                    }\n                    if (i === 0)\n                        throw new Error('no dense output available for component ' + c);\n                    var theta = (x - xOld) / h;\n                    var theta1 = 1 - theta;\n                    var phthet = y[i] + theta * (y[nrd + i] + theta1 * (y[2 * nrd + i] * theta + y[3 * nrd + i] * theta1));\n                    if (imit < 0)\n                        return phthet;\n                    var thetah = theta - 0.5;\n                    var ret = y[nrd * (imit + 4) + i];\n                    for (var im = imit; im >= 1; --im) {\n                        ret = y[nrd * (im + 3) + i] + ret * thetah / im;\n                    }\n                    return phthet + Math.pow(theta * theta1, 2) * ret;\n                };\n            };\n            var ySafe = Solver.dim2(km, nrd);\n            var hh = Solver.dim(km);\n            var t = Solver.dim2(km, _this.n);\n            var nj = Solver.stepSizeSequence(nSeq, km);\n            var a = Solver.dim(km);\n            a[1] = 1 + nj[1];\n            for (var i = 2; i <= km; ++i) {\n                a[i] = a[i - 1] + nj[i];\n            }\n            var scal = Solver.dim(_this.n);\n            for (var i = 1; i <= _this.n; ++i) {\n                scal[i] = aTol[i] + rTol[i] + Math.abs(y[i]);\n            }\n            var posneg = xEnd - x >= 0 ? 1 : -1;\n            var k = Math.max(2, Math.min(km - 1, Math.floor(-Solver.log10(rTol[1] + 1e-40) * 0.6 + 1.5)));\n            var h = Math.max(Math.abs(_this.initialStepSize), 1e-4);\n            h = posneg * Math.min(h, hMax, Math.abs(xEnd - x) / 2);\n            var iPoint = Solver.dim(km + 1);\n            var errfac = Solver.dim(2 * km);\n            var xOld = x;\n            var iPt = 0;\n            if (solOut) {\n                if (_this.denseOutput) {\n                    iPoint[1] = 0;\n                    for (var i = 1; i <= km; ++i) {\n                        var njAdd = 4 * i - 2;\n                        if (nj[i] > njAdd)\n                            ++njAdd;\n                        iPoint[i + 1] = iPoint[i] + njAdd;\n                    }\n                    for (var mu = 1; mu <= 2 * km; ++mu) {\n                        var errx = Math.sqrt(mu / (mu + 4)) * 0.5;\n                        var prod = Math.pow(1 / (mu + 4), 2);\n                        for (var j = 1; j <= mu; ++j)\n                            prod *= errx / j;\n                        errfac[mu] = prod;\n                    }\n                    iPt = 0;\n                }\n                if (false === solOut(nAccept + 1, xOld, x, y.slice(1))) {\n                    return Outcome.EarlyReturn;\n                }\n            }\n            var err = 0;\n            var errOld = 1e10;\n            var hoptde = posneg * hMax;\n            var w = Solver.dim(km);\n            w[1] = 0;\n            var reject = false;\n            var last = false;\n            var atov;\n            var kc = 0;\n            var STATE;\n            (function (STATE) {\n                STATE[STATE[\"Start\"] = 0] = \"Start\";\n                STATE[STATE[\"BasicIntegrationStep\"] = 1] = \"BasicIntegrationStep\";\n                STATE[STATE[\"ConvergenceStep\"] = 2] = \"ConvergenceStep\";\n                STATE[STATE[\"HopeForConvergence\"] = 3] = \"HopeForConvergence\";\n                STATE[STATE[\"Accept\"] = 4] = \"Accept\";\n                STATE[STATE[\"Reject\"] = 5] = \"Reject\";\n            })(STATE || (STATE = {}));\n            var state = STATE.Start;\n            loop: while (true) {\n                _this.debug && console.log('STATE', STATE[state], nStep, xOld, x, h, k, kc, hoptde);\n                switch (state) {\n                    case STATE.Start:\n                        atov = false;\n                        if (0.1 * Math.abs(xEnd - x) <= Math.abs(x) * _this.uRound)\n                            break loop;\n                        h = posneg * Math.min(Math.abs(h), Math.abs(xEnd - x), hMax, Math.abs(hoptde));\n                        if ((x + 1.01 * h - xEnd) * posneg > 0) {\n                            h = xEnd - x;\n                            last = true;\n                        }\n                        if (nStep === 0 || !_this.denseOutput) {\n                            F(x, y, dz);\n                            ++nEval;\n                        }\n                        if (nStep === 0 || last) {\n                            iPt = 0;\n                            ++nStep;\n                            for (var j = 1; j <= k; ++j) {\n                                kc = j;\n                                midex(j);\n                                if (atov)\n                                    continue loop;\n                                if (j > 1 && err <= 1) {\n                                    state = STATE.Accept;\n                                    continue loop;\n                                }\n                            }\n                            state = STATE.HopeForConvergence;\n                            continue;\n                        }\n                        state = STATE.BasicIntegrationStep;\n                        continue;\n                    case STATE.BasicIntegrationStep:\n                        iPt = 0;\n                        ++nStep;\n                        if (nStep >= _this.maxSteps) {\n                            return Outcome.MaxStepsExceeded;\n                        }\n                        kc = k - 1;\n                        for (var j = 1; j <= kc; ++j) {\n                            midex(j);\n                            if (atov) {\n                                state = STATE.Start;\n                                continue loop;\n                            }\n                        }\n                        if (k === 2 || reject) {\n                            state = STATE.ConvergenceStep;\n                        }\n                        else {\n                            if (err <= 1) {\n                                state = STATE.Accept;\n                            }\n                            else if (err > Math.pow((nj[k + 1] * nj[k]) / 4, 2)) {\n                                state = STATE.Reject;\n                            }\n                            else\n                                state = STATE.ConvergenceStep;\n                        }\n                        continue;\n                    case STATE.ConvergenceStep:\n                        midex(k);\n                        if (atov) {\n                            state = STATE.Start;\n                            continue;\n                        }\n                        kc = k;\n                        if (err <= 1) {\n                            state = STATE.Accept;\n                            continue;\n                        }\n                        state = STATE.HopeForConvergence;\n                        continue;\n                    case STATE.HopeForConvergence:\n                        if (err > Math.pow(nj[k + 1] / 2, 2)) {\n                            state = STATE.Reject;\n                            continue;\n                        }\n                        kc = k + 1;\n                        midex(kc);\n                        if (atov)\n                            state = STATE.Start;\n                        else if (err > 1)\n                            state = STATE.Reject;\n                        else\n                            state = STATE.Accept;\n                        continue;\n                    case STATE.Accept:\n                        if (!acceptStep(_this.n))\n                            return Outcome.EarlyReturn;\n                        state = STATE.Start;\n                        continue;\n                    case STATE.Reject:\n                        k = Math.min(k, kc, km - 1);\n                        if (k > 2 && w[k - 1] < w[k] * _this.stepSizeFac3)\n                            k -= 1;\n                        ++nReject;\n                        h = posneg * hh[k];\n                        reject = true;\n                        state = STATE.BasicIntegrationStep;\n                }\n            }\n            return Outcome.Converged;\n        };\n        var outcome = odxcor();\n        return {\n            y: y.slice(1),\n            outcome: outcome,\n            nStep: nStep,\n            xEnd: xEnd,\n            nAccept: nAccept,\n            nReject: nReject,\n            nEval: nEval\n        };\n    };\n    Solver.dim = function (n) { return Array(n + 1); };\n    Solver.log10 = function (x) { return Math.log(x) / Math.LN10; };\n    return Solver;\n}());\nexports.Solver = Solver;\n\n},{}],2:[function(require,module,exports){\n\"use strict\";\nvar odex_1 = require('./node_modules/odex/src/odex');\nvar twoPi = Math.PI * 2;\nvar StandardMap = (function () {\n    function StandardMap(K) {\n        this.evolve = function (initialData, n, callback) {\n            var theta = initialData[0], I = initialData[1];\n            for (var i = 0; i < n; ++i) {\n                callback(theta, I);\n                var nI = I + (this.K * Math.sin(theta));\n                theta = this.PV(theta + nI);\n                I = this.PV(nI);\n            }\n        };\n        this.K = K;\n        this.PV = StandardMap.principal_value(twoPi);\n    }\n    StandardMap.principal_value = function (cuthigh) {\n        var cutlow = cuthigh - twoPi;\n        return function (x) {\n            if (cutlow <= x && x < cuthigh) {\n                return x;\n            }\n            var y = x - twoPi * Math.floor(x / twoPi);\n            return y < cuthigh ? y : y - twoPi;\n        };\n    };\n    StandardMap.prototype.run = function (theta, I, point, fail) {\n        var nI = I + (this.K * Math.sin(theta));\n        point(this.PV(theta + nI), this.PV(nI));\n    };\n    StandardMap.twoPi = 2 * Math.PI;\n    return StandardMap;\n}());\nexports.StandardMap = StandardMap;\nvar DrivenPendulumMap = (function () {\n    function DrivenPendulumMap() {\n        this.S = new odex_1.Solver(3);\n        this.S.denseOutput = true;\n        var l = 1;\n        var g = 9.8;\n        var w0 = Math.sqrt(g / l);\n        var w = 2 * w0;\n        this.T = 2 * Math.PI / w;\n        var a = 0.1;\n        console.log('l', l, 'a', a, 'w', w, 'g', g);\n        this.d = DrivenPendulumMap.F(1, l, a, w, g);\n        this.PV = StandardMap.principal_value(Math.PI);\n    }\n    DrivenPendulumMap.prototype.evolve = function (initialData, n, callback) {\n        var _this = this;\n        this.S.solve(this.d, 0, [0].concat(initialData), 1000 * this.T, this.S.grid(this.T, function (x, ys) {\n            callback(_this.PV(ys[1]), ys[2]);\n        }));\n    };\n    DrivenPendulumMap.F = function (m, l, a, omega, g) { return function (x, _a) {\n        var t = _a[0], theta = _a[1], p_theta = _a[2];\n        var _1 = Math.sin(omega * t);\n        var _2 = Math.pow(l, 2);\n        var _3 = omega * t;\n        var _4 = Math.sin(theta);\n        var _5 = Math.cos(theta);\n        return [1, (Math.sin(_3) * _4 * a * l * m * omega + p_theta) / _2 * m, (-Math.pow(Math.sin(_3), 2) * _4 * _5 * Math.pow(a, 2) * l * m * Math.pow(omega, 2) - Math.sin(_3) * _5 * a * omega * p_theta - _4 * g * _2 * m) / l];\n    }; };\n    return DrivenPendulumMap;\n}());\nexports.DrivenPendulumMap = DrivenPendulumMap;\nvar ExploreMap = (function () {\n    function ExploreMap(canvas, M, xRange, yRange) {\n        var _this = this;\n        this.canvas = document.getElementById(canvas);\n        this.M = M;\n        this.context = this.canvas.getContext('2d');\n        var _a = [xRange[1] - xRange[0], yRange[1] - yRange[0]], w = _a[0], h = _a[1];\n        console.log('w', w, 'h', h);\n        this.canvas.onmousedown = function (e) {\n            var _a = [e.offsetX / _this.context.canvas.width * w + xRange[0],\n                yRange[1] - e.offsetY / _this.context.canvas.height * h], cx = _a[0], cy = _a[1];\n            _this.Explore(cx, cy);\n        };\n        this.context.scale(this.context.canvas.width / w, -this.context.canvas.height / h);\n        this.context.translate(-xRange[0], -yRange[1]);\n    }\n    ExploreMap.prototype.pt = function (x, y) {\n        this.context.fillStyle = 'rgba(23,64,170,0.3)';\n        this.context.beginPath();\n        this.context.arc(x, y, 0.01, 0, 2 * Math.PI);\n        this.context.fill();\n        this.context.closePath();\n    };\n    ExploreMap.prototype.Explore0 = function (x, y) {\n        var _this = this;\n        for (var i = 0; i < 1000; ++i) {\n            this.M.run(x, y, function (xp, yp) {\n                _this.pt(xp, yp);\n                x = xp;\n                y = yp;\n            }, function () {\n                console.log('FAIL');\n            });\n        }\n    };\n    ExploreMap.prototype.Explore = function (x, y) {\n        this.M.evolve([x, y], 1000, this.pt.bind(this));\n    };\n    return ExploreMap;\n}());\nexports.ExploreMap = ExploreMap;\n\n},{\"./node_modules/odex/src/odex\":1}]},{},[2])(2)\n});"],"file":"js/standard-map.bundle.js","sourceRoot":"/public"}